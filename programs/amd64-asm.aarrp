; TODO build out these comments to describe generally how to encode x86_64 instructions from
; a table.

; REX: 0100WRXB
; * W: 1 = 64-bit operands, 0 = 32 bit operands
; * R: 1 = extend register access r8-r15
; * X: 1 = SIB byte index field can use r8-r15
; * B: 1 = R/M can use r8-r15 - AND - SIB base field can use r8-r15

; MODRM: mod + reg + r/m
; * mod = addressing mode
;   * 00 = mem
;   * 01 = mem+disp8
;   * 10 = mem+disp32
;   * 11 = register direct
;   * When mod = 00 and r/m = 101, it's absolute 32-bit address or RIP-relative addressing (which?)
;   * When r/m = 100, it's always SIB
; * reg (3 bits):
;   * 000 rax/eax
;   * 001 rcx/ecx
;   * 010 rdx/edx
;   * 011 rbx/ebx
;   * 100 rsp/esp
;   * 101 rbp/ebp
;   * 110 rsi/esi
;   * 111 rdi/edi
; * reg (3 bits) when R is 1:
;   * 000 r8
;   * 001 r9
;   * 010 r10
;   * 011 r11
;   * 100 r12
;   * 101 r13
;   * 110 r14
;   * 111 r15
;
; * r/m (3 bits) when mod = 11 encodes another register. Refers to r8+ if REX.B = 1
;
; TODO doc SIB byte

;; TODO special case: spl, bpl, sil, and dil require REX byte, we need to make sure those are
;;      encoded correctly
;;        * This is a proper nightmare because instructions like mov al, spl are now invalid b/c
;;          the REX byte promotes us to 64-bit, we need REX for spl, but no REX for al.
;;        * think about what happens with movzx/movsx and different operand sizes.
;;        * probably do this directly in the with-x86_64-asm macro, don't resolve it in the DSL:
;;          * prepend REX byte if not there in the DSL form and one of these registers is used
;;          * possibly error in some invalid situations that wouldn't work out right
;;          * probably error if one register operand is 32 or 16 bit when these registers are used.
;;        * make sure stuff like mov al, spl produces an error

;; TODO special case: to encode a qword[rsp] operand, we *must* use an SIB byte with base=rsp
;;      even if we're not using scale etc. This is because an r/m value of 100 - rsp's register
;;      number - means SIB.

;; TODO special case: an index of rsp/esp/etc in an SIB byte is invalid, because this register's
;;      number denotes a zero index.
;;        * Make sure we error if the user tries to do this

;; TODO special case: to encode a qword[rbp] operand, we cannot use mod 00/mem. You must use a
;;      displacement encoding and just encode a displacement of zero. This is because rbp's
;;      register number instead denotes RIP-relative addressing.

;; TODO to resolve the above special cases, why not make the first argument of MODRM
;;      include mem-sib and mem-rip-rel. That way, if the user just specified "mem" it could
;;      actually expand into multiple bytes to resolve the problem cases as though they didn't
;;      exist. Unless mem-sib or mem-rip-rel is specified, you know for sure your input number
;;      represents a register intentionally.
;;
;;      ...In fact, in the case of SIB MODRM macro could accept extra parameters to encode the
;;      SIB value, and in the case of disp8/disp32, accept an extra parameter for that value.
;;      This would make "MODRM" a bit of a higher-level abstraction for "memory/register operand"
;;
;;      Building on this, it may make more sense to put the register number field first, as it's
;;      unchanging, then put all of the memory-related operands into a list. That way, in the
;;      mini-DSL a macro could expand into the memory related components in one go (covering
;;      mod, sib, disp8, disp32, rip-rel, everything).
;;
;;      Maybe rename MODRM though if doing this though as the macro name implies that it's
;;      just expanding into the MODRM byte.
;;
;;      Maybe just call the macro "RM" for regmem.
;;
;;      ...Actually, we can even take this one step further and just accept a register number/name
;;      and then our final memory operand interface like (qword rsp*2+2) or something like that.
;;
;;      Actually not quite. 'qword' is defined by the instruction form and has to be resolved
;;      through the instruction table. So maybe just (RM rdi (mem rsp*2+2)) for memory and
;;      (RM rdi rsp) for both registers. Could also optionally accept (RM rdi (qword rsp*2+2)) etc
;;      just to make DSL implementation simpler, and treat it the same as 'mem'.
;;
;;      Normally, I would avoid putting this much into one abstraction, but the special cases
;;      in x86-64 have made all of these components inter-related rather than have proper
;;      separation of concerns. Therefore, the best solution is for us to not separate our
;;      concerns.
;;
;; Memory operands things to check:
;;      (qword 5) for RIP-rel/disp32
;;      Different orders possible: (qword rdi + 5 + rsi * 2)
;;      scale can only be 1 2 4 8
;;      Should error: rdi + rax * 2 + rcx * 4

;; TODO in our memory operands, in addition to qword dword byte etc, we should accept something
;;      like mem8 mem4 mem2 mem1 because that's less annoying.

;; TODO support legacy ah, bh, ch, dh registers?

;; TODO find some kind of assembler encoding test suite
;;   * maybe pull from an existing project: nasm, intel XED, gas, fasm, LLVM MC layer
;;   * maybe port one over to aarrp-land at some point if licensing allows

;; TODO fancy memory operand like (m64 base+index*scale+displace) - implement by building a
;; 'normalize' function that converts it to our current format.
;;   * use m64/m32/m16/m8, not qword/dword/etc
;;   * make sure it works with different orders like index*scale+base+displace
;;   * make sure it works in simplified forms like base+displace

;; TODO: imm* macros should accept (label-rel-ref foo) and (label-abs-ref foo) and expand into the
;; appropriate label: (imm32 (label-rel-ref foo)) should expand into (label-rel-ref foo 4 LE)
;;
;; This is needed so that if you specify (mov rdi (label-rel-ref foo)) it works.
;; This also means the assembler needs to recognize "label-rel-ref" things as imm*
;; values when looking up instructions.


;; TODO: imm* macros should accept stuff like (imm64 0xFF) along with base 10 version.
;; (imm64 0cb) for chars? (imm64 'b')?
;;  Would just need to change the parse-int function.
;; default to base 10.

(aarrp/with

  ;;; --- Data and utility funtions ---
  ((imm64-arg-count-error "ERROR: incorrect number of parameters passed to imm64 (should be 1).\n")
   (REX-input-error       "ERROR: Inputs to REX must be one char each of: WRXBwrxb.\n")
   (MODRM-input-error     "ERROR: Bad input to RM\n")
   (memop-error           "ERROR: Incorrectly formatted or unsupported memory operand.\n")
   (reg-name-to-num-not-found-error "ERROR: invalid register specified\n")

   (MODRM-reg        "reg")
   (MODRM-mem        "mem")
   (MODRM-mem+disp8  "mem+disp8")
   (MODRM-mem+disp32 "mem+disp32")

   (regname-rbp rbp)
   (regname-r13 r13)

   (zero 0)

   (valid-registers (rax eax   ax    al
                     rcx ecx   cx    cl
                     rdx edx   dx    dl
                     rbx ebx   bx    bl
                     rsp esp   sp    spl
                     rbp ebp   bp    bpl
                     rsi esi   si    sil
                     rdi edi   di    dil

                     ;; Extended registers, use REX prefix to access
                     r8  r8d   r8w   r8b
                     r9  r9d   r9w   r9b
                     r10 r10d  r10w  r10b
                     r11 r11d  r11w  r11b
                     r12 r12d  r12w  r12b
                     r13 r13d  r13w  r13b
                     r14 r14d  r14w  r14b
                     r15 r15d  r15w  r15b))

   (reg-num-map ((rax "\x00") (eax  "\x00") (ax   "\x00") (al   "\x00")
                 (rcx "\x01") (ecx  "\x01") (cx   "\x01") (cl   "\x01")
                 (rdx "\x02") (edx  "\x02") (dx   "\x02") (dl   "\x02")
                 (rbx "\x03") (ebx  "\x03") (bx   "\x03") (bl   "\x03")
                 (rsp "\x04") (esp  "\x04") (sp   "\x04") (spl  "\x04")
                 (rbp "\x05") (ebp  "\x05") (bp   "\x05") (bpl  "\x05")
                 (rsi "\x06") (esi  "\x06") (si   "\x06") (sil  "\x06")
                 (rdi "\x07") (edi  "\x07") (di   "\x07") (dil  "\x07")

                 ;; Extended registers, use REX prefix to access
                 (r8  "\x00") (r8d  "\x00") (r8w  "\x00") (r8b  "\x00")
                 (r9  "\x01") (r9d  "\x01") (r9w  "\x01") (r9b  "\x01")
                 (r10 "\x02") (r10d "\x02") (r10w "\x02") (r10b "\x02")
                 (r11 "\x03") (r11d "\x03") (r11w "\x03") (r11b "\x03")
                 (r12 "\x04") (r12d "\x04") (r12w "\x04") (r12b "\x04")
                 (r13 "\x05") (r13d "\x05") (r13w "\x05") (r13b "\x05")
                 (r14 "\x06") (r14d "\x06") (r14w "\x06") (r14b "\x06")
                 (r15 "\x07") (r15d "\x07") (r15w "\x07") (r15b "\x07")))

   ;; TODO implement access function - reg-name-extendedp
   (reg-is-extendend-map ((rax 0) (eax  0) (ax   0) (al   0)
                          (rcx 0) (ecx  0) (cx   0) (cl   0)
                          (rdx 0) (edx  0) (dx   0) (dl   0)
                          (rbx 0) (ebx  0) (bx   0) (bl   0)
                          (rsp 0) (esp  0) (sp   0) (spl  0)
                          (rbp 0) (ebp  0) (bp   0) (bpl  0)
                          (rsi 0) (esi  0) (si   0) (sil  0)
                          (rdi 0) (edi  0) (di   0) (dil  0)

                          ;; Extended registers, use REX prefix to access
                          (r8  1) (r8d  1) (r8w  1) (r8b  1)
                          (r9  1) (r9d  1) (r9w  1) (r9b  1)
                          (r10 1) (r10d 1) (r10w 1) (r10b 1)
                          (r11 1) (r11d 1) (r11w 1) (r11b 1)
                          (r12 1) (r12d 1) (r12w 1) (r12b 1)
                          (r13 1) (r13d 1) (r13w 1) (r13b 1)
                          (r14 1) (r14d 1) (r14w 1) (r14b 1)
                          (r15 1) (r15d 1) (r15w 1) (r15b 1)))

   ;; TODO implement access function - reg-name-sizename
   (reg-sizename-map ((rax r64) (eax  r32) (ax   r16) (al   r8)
                      (rcx r64) (ecx  r32) (cx   r16) (cl   r8)
                      (rdx r64) (edx  r32) (dx   r16) (dl   r8)
                      (rbx r64) (ebx  r32) (bx   r16) (bl   r8)
                      (rsp r64) (esp  r32) (sp   r16) (spl  r8)
                      (rbp r64) (ebp  r32) (bp   r16) (bpl  r8)
                      (rsi r64) (esi  r32) (si   r16) (sil  r8)
                      (rdi r64) (edi  r32) (di   r16) (dil  r8)

                      ;; Extended registers, use REX prefix to access
                      (r8  r64) (r8d  r32) (r8w  r16) (r8b  r8)
                      (r9  r64) (r9d  r32) (r9w  r16) (r9b  r8)
                      (r10 r64) (r10d r32) (r10w r16) (r10b r8)
                      (r11 r64) (r11d r32) (r11w r16) (r11b r8)
                      (r12 r64) (r12d r32) (r12w r16) (r12b r8)
                      (r13 r64) (r13d r32) (r13w r16) (r13b r8)
                      (r14 r64) (r14d r32) (r14w r16) (r14b r8)
                      (r15 r64) (r15d r32) (r15w r16) (r15b r8)))

   ;; writes a barray's bytes to fd (use me to print stuff to stdout/stderr)
   (write-barray-to-fd-fn
     (aarrp/barray-cat
       "\x41\x54"                                   ; push r12
       "\x41\x55"                                   ; push r13
       "\x41\x56"                                   ; push r14

       "\x49\x89\xFD"                               ; mov r13, rdi        - barray
       "\x49\x89\xF6"                               ; mov r14, rsi        - fd

       "\x4D\x8B\x65\x00"                           ; mov r12, qword[r13] - r12 = string length
       "\x49\x83\xC5\x08"                           ; add r13, 8          - move past length

       (label write-loop)
       (label-scope
        "\x4C\x89\xE2"                              ; mov rdx, r12        - String length
        "\x4C\x89\xEE"                              ; mov rsi, r13        - String
        "\x4C\x89\xF7"                              ; mov rdi, r14        - Output fd
        "\x48\xC7\xC0\x01\x00\x00\x00"              ; mov rax, 1          - sys_write
        "\x0F\x05"                                  ; syscall

        "\x48\x83\xF8\x00"                          ; cmp rax, 0
        "\x0F\x8C" (label-rel-ref write-err 4 LE)   ; jl write-err

        "\x49\x29\xC4"                              ; sub r12, rax
        "\x49\x01\xC5"                              ; add r13, rax
        "\x49\x83\xFC\x00"                          ; cmp r12, 0
        "\x0F\x8F" (label-rel-ref write-loop 4 LE)) ; jg write-loop

       (label epilogue)
       "\x41\x5E"                                   ; pop r14
       "\x41\x5D"                                   ; pop r13
       "\x41\x5C"                                   ; pop r12
       "\xC3"                                       ; ret

       (label write-err)
       "\x48\xC7\xC0\x00\x00\x00\x00"               ; mov rax, 0
       "\xE9" (label-rel-ref epilogue 4 LE)))       ; jmp epilogue

   ;; Prints the error barray to stderr (rdi) and exits
   ;; TODO what exit code? we want to make sure it's != 0
   (error-exit-fn
     (aarrp/barray-cat
       ; rdi is already correct
       "\x48\xC7\xC6\x02\x00\x00\x00"                          ; mov rsi, 2 - we want stderr
       "\x48\xB8" (write-barray-to-fd-fn barray-raw-addr 8 LE) ; mov rax, write-barray-to-fd
       "\xFF\xD0"                                              ; call rax

       "\x48\xC7\xC0\x3C\x00\x00\x00"                          ; mov rax, 60 - sys_exit
       "\x0F\x05"                                              ; syscall
       "\xC3"))                                                ; ret

   ;; Outputs a register number given a barray input (rdi) of a register name
   ;;
   ;; Note: due to the way extended registers work, there are multiple registers with the same
   ;; number. R8 number == rax number for example. See reg-num-map.
   (reg-name-to-num
     (aarrp/barray-cat
       "\x41\x54"     ; push r12
       "\x41\x55"     ; push r13
       "\x41\x56"     ; push r14
       "\x41\x57"     ; push r15
       "\x53"         ; push rbx

       "\x49\x89\xFC"                    ; mov r12, rdi
       "\x49\xBE"(reg-num-map addr 8 LE) ; mov r14, reg-num-map
       "\x4D\x8B\x2E"                    ; mov r13, qword[r14]
       "\x49\xF7\xD5"                    ; not r13 - r13 = table entry count
       "\x49\x83\xC6\x08"                ; add r14, 8 - move past length

       ;; Iterate over reg-num-map
       (label table-loop)
       (label-scope
        "\x49\x83\xFD\x00" ; cmp r13, 0
        "\x0F\x8E"(label-rel-ref table-loop-break 4 LE) ; jle table-loop-break

        "\x4D\x8B\x3E" ; mov r15, qword[r14] - r15 = pointer to table entry

        "\x4C\x89\xE7"                                       ; mov rdi, r12
        "\x49\x8B\x77\x08"                                   ; mov rsi, qword[r15+8]
        "\x48\xB8"(aarrp/builtin-func-addr/barray-equalp)    ; mov rax, barray-equalp
        "\xFF\xD0"                                           ; call rax
        "\x48\x83\xF8\x01" ; cmp rax, 1
        "\x49\x8B\x7F\x10" ; mov rdi, qword[r15+16]
        "\xB8\x00\x00\x00\x00" ; mov rax, 0
        "\x8A\x47\x08" ; mov al, byte[rdi+8]
        "\x0F\x84" (label-rel-ref table-loop-found 4 LE) ; je table-loop-found

        "\x49\x83\xC6\x08" ; add r14, 8
        "\x49\xFF\xCD"     ; dec r13
        "\xE9" (label-rel-ref table-loop 4 LE)) ; jmp table-loop
       (label table-loop-break)

       ;; Error if we get here, didn't find a match
       "\x48\xBF" (reg-name-to-num-not-found-error addr 8 LE) ; mov rdi, error
       "\x48\xB8" (error-exit-fn barray-raw-addr 8 LE)        ; mov rax, error-exit-fn
       "\xFF\xD0"                                             ; call rax

       (label table-loop-found)

       "\x5B"     ; pop rbx
       "\x41\x5F" ; pop r15
       "\x41\x5E" ; pop r14
       "\x41\x5D" ; pop r13
       "\x41\x5C" ; pop r12
       "\xC3"))   ; ret

   ;; Produces error and exits if the parray (rdi) doesn't have rsi elements
   (check-arg-count-fn
     (aarrp/barray-cat
       "\x48\x8B\x4F\x00"                              ; mov rcx, qword[rdi]
       "\x48\xF7\xD1"                                  ; not rcx
       "\x48\x39\xF1"                                  ; cmp rcx, rsi
       "\x0F\x84" (label-rel-ref good 4 LE)            ; je good

       "\x48\xBF" (imm64-arg-count-error addr 8 LE)    ; mov rdi, error-barray-addr
       "\x48\xB8" (error-exit-fn barray-raw-addr 8 LE) ; mov rax, error-exit-fn
       "\xFF\xD0"                                      ; call rax

       (label good)
       "\xC3"))                                        ; ret 

   ;; Converts a single ascii char to the digit it represents. Works up to base 36.
   (ascii-to-digit-fn
     (aarrp/barray-cat
       "\x48\x89\xF8"                                      ; mov rax, rdi

       "\x48\x83\xF8\x39"                                  ; cmp rax, 57
       "\x0F\x8F" (label-rel-ref as-uppercase-letter 4 LE) ; jg as-uppercase-letter

       "\x48\x83\xE8\d048"                                 ; sub rax, 48
       "\xC3"                                              ; ret

       (label as-uppercase-letter)
       "\x48\x83\xF8\d090"                                 ; cmp rax, 90
       "\x0F\x8F" (label-rel-ref as-lowercase-letter 4 LE) ; jg as-lowercase-letter

       "\x48\x83\xE8\d055"                                 ; sub rax, 55
       "\xC3"                                              ; ret

       (label as-lowercase-letter)
       "\x48\x83\xE8\d087"                                 ; sub rax, 87
       "\xC3"))                                            ; ret

    ;; parses a signed ascii integer from barray in rdi assuming it is in base rsi
    (parse-int-fn
      (aarrp/barray-cat
        "\x41\x54"     ; push r12
        "\x41\x55"     ; push r13
        "\x41\x56"     ; push r14
        "\x41\x57"     ; push r15
        "\x53"         ; push rbx

        "\x49\x89\xFC" ; mov r12, rdi - r12 = input barray
        "\x49\x89\xF5" ; mov r13, rsi - r13 = base

        "\x4D\x8B\x3C\x24"     ; mov r15, qword[r12] - r15 = barray length
        "\x49\x83\xC4\x08"     ; add r12, 8 - move past length

        ;; Loop working right-to-left
        "\x4D\x31\xF6"                 ; xor r14, r14 - result
        "\x48\xC7\xC3\x01\x00\x00\x00" ; mov rbx, 1   - multiplier

        (label loop)
        (label-scope
         "\x49\x83\xFF\x00"                         ; cmp r15, 0
         "\x0F\x84" (label-rel-ref loop-break 4 LE) ; je loop-break

         ;; If r15 == 1 (the last char), and the char is '-', take the two's complement of
         ;; the result and break the loop.
         "\x49\x83\xFF\x01"                      ; cmp r15, 1
         "\x0F\x85" (label-rel-ref not-neg 4 LE) ; jne not-neg
         "\x43\x80\x7c\x3c\xff\x2d"              ; cmp byte[r12+r15-1], '-'
         "\x0F\x85" (label-rel-ref not-neg 4 LE) ; jne not-neg

         "\x49\xF7\xDE"                         ; neg r14
         "\xE9" (label-rel-ref loop-break 4 LE) ; jmp loop-break

         (label not-neg)

         ;; Parse digit
         "\x48\x31\xFF"         ; xor rdi, rdi
         "\x43\x8A\x7C\x3C\xFF" ; mov dil, byte[r12+r15-1]
         "\x48\xB8" (ascii-to-digit-fn barray-raw-addr 8 LE)  ; mov rax, ascii-to-digit-fn
         "\xFF\xD0"                                                   ; call rax

         ;; TODO error if digit >= base?
         ;; TODO error if digit < 0?

         "\x48\xF7\xE3" ; mul rbx - multiply digit by multiplier
         "\x49\x01\xC6" ; add r14, rax - add to result

         ;; Update multiplier
         "\x48\x89\xD8" ; mov rax, rbx
         "\x49\xF7\xE5" ; mul r13
         "\x48\x89\xC3" ; mov rbx, rax

         "\x49\xFF\xCF" ; dec r15
         "\xE9" (label-rel-ref loop 4 LE)) ; jmp loop
        (label loop-break)

        "\x4C\x89\xF0" ; mov rax, r14
        "\x5B"     ; pop rbx
        "\x41\x5F" ; pop r15
        "\x41\x5E" ; pop r14
        "\x41\x5D" ; pop r13
        "\x41\x5C" ; pop r12
        "\xC3"))   ; ret

   ;; Attempts to write MODRM and associated bytes for a rip-rel RM encoding.
   ;;   * rdi = normalized memory operand (m* base index scale disp), rsi = output byte buffer
   ;;   * reg field will be 0.
   ;;   * returns 1 (on success) or 0 (not possible to encode this memory operand as rip-rel)
   (RM-try-encode-rip-rel-fn
     (aarrp/barray-cat
       "\x41\x54" ; push r12
       "\x41\x55" ; push r13
       "\x41\x56" ; push r14

       "\x49\x89\xFC" ; mov r12, rdi - memory operand
       "\x49\x89\xF5" ; mov r13, rsi - output byte buffer

       ;; We can use rip-rel if base == ascii_0 && index == ascii_0

       ;; If our input is not a parray of length 5, goto nope
       "\x49\x83\x3C\x24\xFA"               ; cmp qword[r12], -6
       "\x0F\x85" (label-rel-ref nope 4 LE) ; jne nope

       ;; If 'base' is not a barray of length one, goto nope
       "\x49\x8B\x7C\x24\x10"               ; mov rdi, qword[r12+16]
       "\x48\x83\x3F\x01"                   ; cmp qword[rdi], 1
       "\x0F\x85" (label-rel-ref nope 4 LE) ; jne nope

       ;; If the 'base' byte is not ascii '0', goto nope
       "\x49\x8B\x7C\x24\x10"               ; mov rdi, qword[r12+16]
       "\x80\x7F\x08\x30"                   ; cmp byte[rdi+8], '0'
       "\x0F\x85" (label-rel-ref nope 4 LE) ; jne nope

       ;; If 'index' is not a barray of length one, goto nope
       "\x49\x8B\x7C\x24\x18"               ; mov rdi, qword[r12+24]
       "\x48\x83\x3F\x01"                   ; cmp qword[rdi], 1
       "\x0F\x85" (label-rel-ref nope 4 LE) ; jne nope

       ;; If the 'index' byte is not ascii '0', goto nope
       "\x49\x8B\x7C\x24\x18"               ; mov rdi, qword[r12+24]
       "\x80\x7F\x08\x30"                   ; cmp byte[rdi+8], '0'
       "\x0F\x85" (label-rel-ref nope 4 LE) ; jne nope

       ;; If 'disp' is not a barray, goto nope
       "\x49\x8B\x7C\x24\x28"              ; mov rdi, qword[r12+40]
       "\x48\x83\x3F\x00"                  ; cmp qword[rdi], 0
       "\x0F\x8C"(label-rel-ref nope 4 LE) ; jl nope

       ;; If we get here, encode the rip-rel MODRM form

       ;; Push a byte of value '5' for MODRM
       "\x4C\x89\xEF"                                             ; mov rdi, r13
       "\xBE\x05\x00\x00\x00"                                     ; mov rsi, 5
       "\x48\xB8"(aarrp/builtin-func-addr/byte-buffer-push-int8)  ; mov rax, bb_push_int8
       "\xFF\xD0"                                                 ; call rax

       ;; Parse our displacement integer
       "\x49\x8B\x7C\x24\x28"                         ; mov rdi, qword[r12+40]
       "\xBE\x0A\x00\x00\x00"                         ; mov rsi, 10
       "\x48\xB8"(parse-int-fn barray-raw-addr 8 LE)  ; mov rax, parse-int-fn
       "\xFF\xD0"                                     ; call rax

       ;; Push our displacement integer as int32
       "\x4C\x89\xEF" ; mov rdi, r13
       "\x48\x89\xC6" ; mov rsi, rax
       "\x48\xB8"(aarrp/builtin-func-addr/byte-buffer-push-int32) ; mov rax, bb_push_int32
       "\xFF\xD0"                                                 ; call rax

       "\x48\xC7\xC0\x01\x00\x00\x00"       ; mov rax, 1
       "\xE9" (label-rel-ref epilogue 4 LE) ; jmp epilogue

       (label nope)
       "\x48\xC7\xC0\x00\x00\x00\x00"       ; mov rax, 0

       (label epilogue)
       "\x41\x5E" ; pop r14
       "\x41\x5D" ; pop r13
       "\x41\x5C" ; pop r12
       "\xC3"))   ; ret

  ;; Returns 1 if the register name barray (rdi) is a valid register name, else 0
  (valid-register-name-p-fn
    (aarrp/barray-cat
      "\x41\x54" ; push r12
      "\x41\x55" ; push r13
      "\x41\x56" ; push r14
      "\x41\x57" ; push r15
      "\x53"     ; push rbx

      "\x49\x89\xFC" ; mov r12, rdi - register name barray

      "\x49\xBD"(valid-registers addr 8 LE) ; mov r13, valid-registers
      "\x4D\x8B\x75\x00"                    ; mov r14, qword[r13]
      "\x49\xF7\xD6"                        ; not r14 - r14 = parray length
      "\x49\x83\xC5\x08"                    ; add r13, 8 - move past length

      (label regloop)
      (label-scope
        "\x49\x83\xFE\x00" ; cmp r14, 0
        "\x0F\x8E"(label-rel-ref regloop-break 4 LE) ; jle regloop-break

        "\x49\x8B\x7D\x00"                                ; mov rdi, qword[r13] - rdi = reg barray*
        "\x4C\x89\xE6"                                    ; mov rsi, r12 - rsi = user input barray
        "\x48\xB8"(aarrp/builtin-func-addr/barray-equalp) ; mov rax, barray-equalp
        "\xFF\xD0"                                        ; call rax
        "\x48\x83\xF8\x01"                                ; cmp rax, 1
        "\x0F\x84"(label-rel-ref found 4 LE)              ; je found

        "\x49\x83\xC5\x08" ; add r13, 8
        "\x49\xFF\xCE" ; dec r14

        "\xE9" (label-rel-ref regloop 4 LE)) ; jmp regloop
      (label regloop-break)

      "\xB8\x00\x00\x00\x00"               ; mov rax, 0
      "\xE9" (label-rel-ref epilogue 4 LE) ; jmp epilogue

      (label found)
      "\xB8\x01\x00\x00\x00" ; mov rax, 1

      (label epilogue)
      "\x5B"     ; pop rbx
      "\x41\x5F" ; pop r15
      "\x41\x5E" ; pop r14
      "\x41\x5D" ; pop r13
      "\x41\x5C" ; pop r12
      "\xC3"))

  ;; Attempts to write MODRM and associated bytes for a straight mem (no disp/SIB) RM encoding.
  ;;   * rdi = normalized memory operand (m* base index scale disp), rsi = output byte buffer
  ;;   * reg field will be 0.
  ;;   * returns 1 (on success) or 0 (not possible to encode this memory operand as straight mem)
  (RM-try-encode-mem-fn
    (aarrp/barray-cat
      "\x41\x54" ; push r12
      "\x41\x55" ; push r13
      "\x41\x56" ; push r14
      "\x41\x57" ; push r15
      "\x53"     ; push rbx

      "\x49\x89\xFC" ; mov r12, rdi - memory operand
      "\x49\x89\xF5" ; mov r13, rsi - output byte buffer

      ;; If base != ascii_0 && base != rbp_or_r13 && base != register_4 &&
      ;; index == ascii_0 && displace == 0, we can encode this memory operand without a
      ;; displacement or SIB byte with mod 00.

      ;; If our input is not a parray of length 5, goto nope
      "\x49\x83\x3C\x24\xFA"              ; cmp qword[r12], -6
      "\x0F\x85"(label-rel-ref nope 4 LE) ; jne nope

      ;; If base isn't a valid register name, goto nope
      "\x49\x8B\x7C\x24\x10"                                     ; mov rdi, qword[r12+16]
      "\x48\xB8" (valid-register-name-p-fn barray-raw-addr 8 LE) ; mov rax, valid-register-name-p
      "\xFF\xD0"                                                 ; call rax
      "\x48\x83\xF8\x01"                                         ; cmp rax, 1
      "\x0F\x85" (label-rel-ref nope 4 LE)                       ; jne nope

      ;; If base == rbp, goto nope
      "\x49\x8B\x7C\x24\x10"                            ; mov rdi, qword[r12+16]
      "\x48\xBE"(regname-rbp addr 8 LE)                 ; mov rsi, regname-rbp
      "\x48\xB8"(aarrp/builtin-func-addr/barray-equalp) ; mov rax, barray-equalp
      "\xFF\xD0"                                        ; call rax
      "\x48\x83\xF8\x01"                                ; cmp rax, 1
      "\x0F\x84" (label-rel-ref nope 4 LE)              ; je nope

      ;; If base == r13, goto nope
      "\x49\x8B\x7C\x24\x10"                            ; mov rdi, qword[r12+16]
      "\x48\xBE"(regname-r13 addr 8 LE)                 ; mov rsi, regname-r13
      "\x48\xB8"(aarrp/builtin-func-addr/barray-equalp) ; mov rax, barray-equalp
      "\xFF\xD0"                                        ; call rax
      "\x48\x83\xF8\x01"                                ; cmp rax, 1
      "\x0F\x84" (label-rel-ref nope 4 LE)              ; je nope

      ;; If reg-name-to-num(base) == 4, goto nope (we can't do rsp and friends)
      "\x49\x8B\x7C\x24\x10"                           ; mov rdi, qword[r12+16]
      "\x48\xB8"(reg-name-to-num barray-raw-addr 8 LE) ; mov rax, reg-name-to-num
      "\xFF\xD0"                                       ; call rax
      "\x48\x83\xF8\x04"                               ; cmp rax, 4
      "\x0F\x84" (label-rel-ref nope 4 LE)              ; je nope

      ;; If index != ascii '0', goto nope
      "\x49\x8B\x7C\x24\x18"                            ; mov rdi, qword[r12+24]
      "\x48\xBE"(zero addr 8 LE)                        ; mov rsi, zero
      "\x48\xB8"(aarrp/builtin-func-addr/barray-equalp) ; mov rax, barray-equalp
      "\xFF\xD0"                                        ; call rax
      "\x48\x83\xF8\x01"                                ; cmp rax, 1
      "\x0F\x85" (label-rel-ref nope 4 LE)              ; jne nope

      ;; If displace != ascii '0', goto nope
      "\x49\x8B\x7C\x24\x28"                            ; mov rdi, qword[r12+40]
      "\x48\xBE"(zero addr 8 LE)                        ; mov rsi, zero
      "\x48\xB8"(aarrp/builtin-func-addr/barray-equalp) ; mov rax, barray-equalp
      "\xFF\xD0"                                        ; call rax
      "\x48\x83\xF8\x01"                                ; cmp rax, 1
      "\x0F\x85" (label-rel-ref nope 4 LE)              ; jne nope

      ;; If we get here, encode our MODRM. Just write a byte for the register number in 'base'
      "\x49\x8B\x7C\x24\x10"                           ; mov rdi, qword[r12+16]
      "\x48\xB8"(reg-name-to-num barray-raw-addr 8 LE) ; mov rax, reg-name-to-num
      "\xFF\xD0"                                       ; call rax

      "\x4C\x89\xEF"                                            ; mov rdi, r13
      "\x48\x89\xC6"                                            ; mov rsi, rax
      "\x48\xB8"(aarrp/builtin-func-addr/byte-buffer-push-int8) ; mov rax, bb_push_byte
      "\xFF\xD0"                                                ; call rax

      "\xB8\x01\x00\x00\x00" ; mov rax, 1
      "\xE9" (label-rel-ref epilogue 4 LE) ; jmp epilogue
      (label nope)
      "\x48\xC7\xC0\x00\x00\x00\x00"       ; mov rax, 0

      (label epilogue)
      "\x5B"     ; pop rbx
      "\x41\x5F" ; pop r15
      "\x41\x5E" ; pop r14
      "\x41\x5D" ; pop r13
      "\x41\x5C" ; pop r12
      "\xC3"))   ; ret

  (RM-try-encode-mem+disp-fn
    (aarrp/barray-cat
      "\x41\x54" ; push r12
      "\x41\x55" ; push r13
      "\x41\x56" ; push r14
      "\x41\x57" ; push r15
      "\x53"     ; push rbx

      "\x49\x89\xFC" ; mov r12, rdi - memory operand
      "\x49\x89\xF5" ; mov r13, rsi - output byte buffer

      ;; If base != ascii_0 && base != register_4 && index == ascii_0, we can encode this memory
      ;; operand with mem+disp with mod 01 or mod 10 depending on displacement size.

      ;; If our input is not a parray of length 5, goto nope
      "\x49\x83\x3C\x24\xFA"              ; cmp qword[r12], -6
      "\x0F\x85"(label-rel-ref nope 4 LE) ; jne nope

      ;; If base isn't a valid register name, goto nope
      "\x49\x8B\x7C\x24\x10"                                     ; mov rdi, qword[r12+16]
      "\x48\xB8" (valid-register-name-p-fn barray-raw-addr 8 LE) ; mov rax, valid-register-name-p
      "\xFF\xD0"                                                 ; call rax
      "\x48\x83\xF8\x01"                                         ; cmp rax, 1
      "\x0F\x85" (label-rel-ref nope 4 LE)                       ; jne nope

      ;; If reg-name-to-num(base) == 4, goto nope (we can't do rsp and friends)
      "\x49\x8B\x7C\x24\x10"                           ; mov rdi, qword[r12+16]
      "\x48\xB8"(reg-name-to-num barray-raw-addr 8 LE) ; mov rax, reg-name-to-num
      "\xFF\xD0"                                       ; call rax
      "\x48\x83\xF8\x04"                               ; cmp rax, 4
      "\x0F\x84" (label-rel-ref nope 4 LE)             ; je nope

      ;; If index != ascii '0', goto nope
      "\x49\x8B\x7C\x24\x18"                            ; mov rdi, qword[r12+24]
      "\x48\xBE"(zero addr 8 LE)                        ; mov rsi, zero
      "\x48\xB8"(aarrp/builtin-func-addr/barray-equalp) ; mov rax, barray-equalp
      "\xFF\xD0"                                        ; call rax
      "\x48\x83\xF8\x01"                                ; cmp rax, 1
      "\x0F\x85" (label-rel-ref nope 4 LE)              ; jne nope

      ;; We can encode it. Will be disp8 or disp32 depending on displacement size

      ;; Work out the register number of our base
      "\x49\x8B\x7C\x24\x10"                           ; mov rdi, qword[r12+16]
      "\x48\xB8"(reg-name-to-num barray-raw-addr 8 LE) ; mov rax, reg-name-to-num
      "\xFF\xD0"                                       ; call rax
      "\x49\x89\xC7"                                   ; mov r15, rax

      ;; Parse displacement int
      "\x49\x8B\x7C\x24\x28"                        ; mov rdi, qword[r12+40]
      "\xBE\x0A\x00\x00\x00"                        ; mov rsi, 10
      "\x48\xB8"(parse-int-fn barray-raw-addr 8 LE) ; mov rax, parse-int-fn
      "\xFF\xD0"                                    ; call rax
      "\x49\x89\xC6"                                ; mov r14, rax

      ;; If displacement is too large for disp8, jump to disp32
      "\x48\x83\xF8\x7F"                     ; cmp rax, 127
      "\x0F\x8F" (label-rel-ref disp32 4 LE) ; jg disp32
      "\x48\x83\xF8\x80"                     ; cmp rax, -128
      "\x0F\x8C" (label-rel-ref disp32 4 LE) ; jl disp32

      ;; Encode as disp8 (mod 01)
      "\xBE\x40\x00\x00\x00" ; mov rsi, 64
      "\x4C\x09\xFE"         ; or rsi, r15

      "\x4C\x89\xEF"                                             ; mov rdi, r13
      "\x48\xB8"(aarrp/builtin-func-addr/byte-buffer-push-int8)  ; mov rax, bb_push_int8
      "\xFF\xD0"                                                 ; call rax

      "\x4C\x89\xEF"                                             ; mov rdi, r13
      "\x4C\x89\xF6"                                             ; mov rsi, r14
      "\x48\xB8"(aarrp/builtin-func-addr/byte-buffer-push-int8) ; mov rax, bb_push_int8
      "\xFF\xD0"                                                 ; call rax

      "\xB8\x01\x00\x00\x00" ; mov rax, 1
      "\xE9" (label-rel-ref epilogue 4 LE) ; jmp epilogue

      (label disp32)
      ;; Encode as disp32 (mod 10)
      "\xBE\x80\x00\x00\x00" ; mov rsi, 128
      "\x4C\x09\xFE"         ; or rsi, r15

      "\x4C\x89\xEF"                                             ; mov rdi, r13
      "\x48\xB8"(aarrp/builtin-func-addr/byte-buffer-push-int8)  ; mov rax, bb_push_int8
      "\xFF\xD0"                                                 ; call rax

      "\x4C\x89\xEF"                                             ; mov rdi, r13
      "\x4C\x89\xF6"                                             ; mov rsi, r14
      "\x48\xB8"(aarrp/builtin-func-addr/byte-buffer-push-int32) ; mov rax, bb_push_int32
      "\xFF\xD0"                                                 ; call rax

      "\xB8\x01\x00\x00\x00" ; mov rax, 1
      "\xE9" (label-rel-ref epilogue 4 LE) ; jmp epilogue
      (label nope)
      "\x48\xC7\xC0\x00\x00\x00\x00" ; mov rax, 0

      (label epilogue)
      "\x5B"     ; pop rbx
      "\x41\x5F" ; pop r15
      "\x41\x5E" ; pop r14
      "\x41\x5D" ; pop r13
      "\x41\x5C" ; pop r12
      "\xC3")))  ; ret

  (aarrp/with-macros
    ;;; --- Macros ---

    ;; Encodes imm32 literal from base-10 ASCII number
    ((imm32
       (x86_64-linux
         (aarrp/barray-cat
           "\x41\x54"     ; push r12
           "\x41\x55"     ; push r13
           "\x41\x56"     ; push r14

           "\x49\x89\xFD" ; mov r13, rdi
           "\x49\x89\xF4" ; mov r12, rsi

           ;; Error if wrong argument count (!= 2)
           "\x48\xC7\xC6\x02\x00\x00\x00"                               ; mov rsi, 2 (rdi good)
           "\x48\xB8" (check-arg-count-fn barray-raw-addr 8 LE)         ; mov rax, check-arg-count
           "\xFF\xD0"                                                   ; call rax

           ;; Parse 2nd item in parray as signed base 10 ASCII integer, write integer to output
           "\x4C\x89\xE7"                                               ; mov rdi, r12
           "\x48\xC7\xC6\x04\x00\x00\x00"                               ; mov rsi, 4
           "\x48\xB8" (aarrp/builtin-func-addr/byte-buffer-push-int64)  ; mov rax, bb_push_int64
           "\xFF\xD0"                                                   ; call rax

           "\x49\x8B\x7D\x10"                                           ; mov rdi, qword[r13+16]
           "\x48\xC7\xC6\x0A\x00\x00\x00"                               ; mov rsi, 10
           "\x48\xB8" (parse-int-fn barray-raw-addr 8 LE)               ; mov rax, parse-int
           "\xFF\xD0"                                                   ; call rax

           "\x4C\x89\xE7"                                               ; mov rdi, r12
           "\x48\x89\xC6"                                               ; mov rsi, rax
           "\x48\xB8" (aarrp/builtin-func-addr/byte-buffer-push-int32)  ; mov rax, bb_push_int32
           "\xFF\xD0"                                                   ; call rax

           "\x48\xC7\xC0\x00\x00\x00\x00"                               ; mov rax, 0
           (label epilogue)
           "\x41\x5E"  ; pop r14
           "\x41\x5D"  ; pop r13
           "\x41\x5C"  ; pop r12
           "\xC3")))

    ;; Encodes imm16 literal from base-10 ASCII number
    (imm8
       (x86_64-linux
         (aarrp/barray-cat
           "\x41\x54"     ; push r12
           "\x41\x55"     ; push r13
           "\x41\x56"     ; push r14

           "\x49\x89\xFD" ; mov r13, rdi
           "\x49\x89\xF4" ; mov r12, rsi

           ;; Error if wrong argument count (!= 2)
           "\x48\xC7\xC6"(imm32 2)                                      ; mov rsi, 2 (rdi good)
           "\x48\xB8" (check-arg-count-fn barray-raw-addr 8 LE)         ; mov rax, check-arg-count
           "\xFF\xD0"                                                   ; call rax

           ;; Parse 2nd item in parray as signed base 10 ASCII integer, write integer to output
           "\x4C\x89\xE7"                                               ; mov rdi, r12
           "\x48\xC7\xC6"(imm32 1)                                      ; mov rsi, 1
           "\x48\xB8" (aarrp/builtin-func-addr/byte-buffer-push-int64)  ; mov rax, bb_push_int64
           "\xFF\xD0"                                                   ; call rax

           "\x49\x8B\x7D\x10"                                           ; mov rdi, qword[r13+16]
           "\x48\xC7\xC6"(imm32 10)                                     ; mov rsi, 10
           "\x48\xB8" (parse-int-fn barray-raw-addr 8 LE)               ; mov rax, parse-int
           "\xFF\xD0"                                                   ; call rax

           "\x4C\x89\xE7"                                               ; mov rdi, r12
           "\x48\x89\xC6"                                               ; mov rsi, rax
           "\x48\xB8" (aarrp/builtin-func-addr/byte-buffer-push-int8)  ; mov rax, bb_push_int8
           "\xFF\xD0"                                                   ; call rax

           "\x48\xC7\xC0"(imm32 0)                                      ; mov rax, 0
           (label epilogue)
           "\x41\x5E"  ; pop r14
           "\x41\x5D"  ; pop r13
           "\x41\x5C"  ; pop r12
           "\xC3")))

    ;; Encodes imm16 literal from base-10 ASCII number
    (imm16
       (x86_64-linux
         (aarrp/barray-cat
           "\x41\x54"     ; push r12
           "\x41\x55"     ; push r13
           "\x41\x56"     ; push r14

           "\x49\x89\xFD" ; mov r13, rdi
           "\x49\x89\xF4" ; mov r12, rsi

           ;; Error if wrong argument count (!= 2)
           "\x48\xC7\xC6"(imm32 2)                                      ; mov rsi, 2 (rdi good)
           "\x48\xB8" (check-arg-count-fn barray-raw-addr 8 LE)         ; mov rax, check-arg-count
           "\xFF\xD0"                                                   ; call rax

           ;; Parse 2nd item in parray as signed base 10 ASCII integer, write integer to output
           "\x4C\x89\xE7"                                               ; mov rdi, r12
           "\x48\xC7\xC6"(imm32 2)                                      ; mov rsi, 2
           "\x48\xB8" (aarrp/builtin-func-addr/byte-buffer-push-int64)  ; mov rax, bb_push_int64
           "\xFF\xD0"                                                   ; call rax

           "\x49\x8B\x7D\x10"                                           ; mov rdi, qword[r13+16]
           "\x48\xC7\xC6"(imm32 10)                                     ; mov rsi, 10
           "\x48\xB8" (parse-int-fn barray-raw-addr 8 LE)               ; mov rax, parse-int
           "\xFF\xD0"                                                   ; call rax

           "\x4C\x89\xE7"                                               ; mov rdi, r12
           "\x48\x89\xC6"                                               ; mov rsi, rax
           "\x48\xB8" (aarrp/builtin-func-addr/byte-buffer-push-int16)  ; mov rax, bb_push_int16
           "\xFF\xD0"                                                   ; call rax

           "\x48\xC7\xC0"(imm32 0)                                      ; mov rax, 0
           (label epilogue)
           "\x41\x5E"  ; pop r14
           "\x41\x5D"  ; pop r13
           "\x41\x5C"  ; pop r12
           "\xC3")))

     ;; Encodes imm64 literal from base-10 ASCII number
     (imm64
       (x86_64-linux
        (aarrp/barray-cat
          "\x41\x54"     ; push r12
          "\x41\x55"     ; push r13
          "\x41\x56"     ; push r14

          "\x49\x89\xFD" ; mov r13, rdi
          "\x49\x89\xF4" ; mov r12, rsi

          ;; Error if wrong argument count (!= 2)
          "\x48\xC7\xC6"(imm32 2)                                      ; mov rsi, 2 (rdi good)
          "\x48\xB8" (check-arg-count-fn barray-raw-addr 8 LE)         ; mov rax, check-arg-count
          "\xFF\xD0"                                                   ; call rax

          ;; Parse 2nd item in parray as signed base 10 ASCII integer, write integer to output
          "\x4C\x89\xE7"                                               ; mov rdi, r12
          "\x48\xC7\xC6"(imm32 8)                                      ; mov rsi, 8
          "\x48\xB8" (aarrp/builtin-func-addr/byte-buffer-push-int64)  ; mov rax, bb_int64
          "\xFF\xD0"                                                   ; call rax

          "\x49\x8B\x7D\x10"                                           ; mov rdi, qword[r13+16]
          "\x48\xC7\xC6"(imm32 10)                                     ; mov rsi, 10
          "\x48\xB8" (parse-int-fn barray-raw-addr 8 LE)               ; mov rax, parse-int
          "\xFF\xD0"                                                   ; call rax

          "\x4C\x89\xE7"                                               ; mov rdi, r12
          "\x48\x89\xC6"                                               ; mov rsi, rax
          "\x48\xB8" (aarrp/builtin-func-addr/byte-buffer-push-int64)  ; mov rax, bb_push_int64
          "\xFF\xD0"                                                   ; call rax

          "\x48\xC7\xC0"(imm32 0)                                      ; mov rax, 0

          (label epilogue)
          "\x41\x5E"  ; pop r14
          "\x41\x5D"  ; pop r13
          "\x41\x5C"  ; pop r12
          "\xC3")))   ; ret

      (REX
        (x86_64-linux
          (aarrp/barray-cat
           "\x41\x54"     ; push r12
           "\x41\x55"     ; push r13
           "\x41\x56"     ; push r14
           "\x41\x57"     ; push r15
           "\x53"         ; push rbx

           "\x49\x89\xFC"                 ; mov r12, rdi  - input structure
           "\x49\x89\xF5"                 ; mov r13, rsi  - output byte buffer
           "\x49\xC7\xC6\x40\x00\x00\x00" ; mov r14, 0x40 - init output number to 0100 0000

           "\x4C\x8B\x7F\x00" ; mov r15, qword[rdi]
           "\x49\xF7\xD7"     ; not r15
           "\x49\xFF\xCF"     ; dec r15 - r15 = input parray length - 1

           "\x48\x89\xFB"     ; mov rbx, rdi
           "\x48\x83\xC3\x10" ; add rbx, 16 - move past length and first element

           ;; Iterate over elements of our input structure excluding first
           (label element-loop)
           (label-scope
            "\x49\x83\xFF\x00" ; cmp r15, 0
            "\x0F\x84" (label-rel-ref element-loop-break 4 LE) ; je element-loop-break

            "\x48\x8B\x4B\x00" ; mov rcx, qword[rbx] - rcx = pointer to element
            "\x48\xC7\xC2"(imm32 8) ; mov rdx, 8

            ;; if the element isn't a barray of length 1, error
            "\x48\x83\x39"(imm8 1)                     ; cmp qword[rcx], 1
            "\x0F\x84" (label-rel-ref good-input 4 LE) ; je good-input

            "\x48\xBF" (REX-input-error addr 8 LE) ; mov rdi, REX-input-error
            "\x48\xB8" (error-exit-fn barray-raw-addr 8 LE) ; mov rax, error-exit-fn
            "\xFF\xD0" ; call rax

            (label good-input)

            ;; If the barray is 'W' or 'w', set the 1st bit
            "\x80\x79\x08" W                       ; cmp byte[rcx+8], 'W'
            "\x0F\x84" (label-rel-ref is-w 4 LE)   ; je is-w
            "\x80\x79\x08" w                       ; cmp byte[rcx+8], 'w'
            "\x0F\x84" (label-rel-ref is-w 4 LE)   ; je is-w
            "\xE9" (label-rel-ref is-not-w 4 LE)   ; jmp is-not-w
            (label is-w)
            "\x49\x09\xD6"                         ; or r14, rdx
            "\xE9" (label-rel-ref continue 4 LE)   ; jmp continue
            (label is-not-w)

            "\x48\xD1\xEA" ; shr rdx

            ;; If the barray is 'R' or 'r', set the 2nd bit
            "\x80\x79\x08" R                       ; cmp byte[rcx+8], 'R'
            "\x0F\x84" (label-rel-ref is-r 4 LE)   ; je is-r
            "\x80\x79\x08" r                       ; cmp byte[rcx+8], 'r'
            "\x0F\x84" (label-rel-ref is-r 4 LE)   ; je is-r
            "\xE9" (label-rel-ref is-not-r 4 LE)   ; jmp is-not-r
            (label is-r)
            "\x49\x09\xD6"                         ; or r14, rdx
            "\xE9" (label-rel-ref continue 4 LE)   ; jmp continue
            (label is-not-r)

            "\x48\xD1\xEA" ; shr rdx

            ;; If the barray is 'X' or 'x', set the 3rd bit
            "\x80\x79\x08" X                       ; cmp byte[rcx+8], 'X'
            "\x0F\x84" (label-rel-ref is-x 4 LE)   ; je is-x
            "\x80\x79\x08" x                       ; cmp byte[rcx+8], 'x'
            "\x0F\x84" (label-rel-ref is-x 4 LE)   ; je is-x
            "\xE9" (label-rel-ref is-not-x 4 LE)   ; jmp is-not-x
            (label is-x)
            "\x49\x09\xD6"                         ; or r14, rdx
            "\xE9" (label-rel-ref continue 4 LE)   ; jmp continue
            (label is-not-x)

            "\x48\xD1\xEA" ; shr rdx

            ;; If the barray is 'B' or 'b', set the 4th bit
            "\x80\x79\x08" B                       ; cmp byte[rcx+8], 'B'
            "\x0F\x84" (label-rel-ref is-b 4 LE)   ; je is-b
            "\x80\x79\x08" b                       ; cmp byte[rcx+8], 'b'
            "\x0F\x84" (label-rel-ref is-b 4 LE)   ; je is-b
            "\xE9" (label-rel-ref is-not-b 4 LE)   ; jmp is-not-b
            (label is-b)
            "\x49\x09\xD6"                         ; or r14, rdx
            "\xE9" (label-rel-ref continue 4 LE)   ; jmp continue
            (label is-not-b)

            ;; If we get here, error
            "\x48\xBF" (REX-input-error addr 8 LE) ; mov rdi, REX-input-error
            "\x48\xB8" (error-exit-fn barray-raw-addr 8 LE) ; mov rax, error-exit-fn
            "\xFF\xD0" ; call rax

            (label continue)
            "\x48\x83\xC3"(imm8 8)                    ; add rbx, 8
            "\x49\xFF\xCF"                            ; dec r15
            "\xE9" (label-rel-ref element-loop 4 LE)) ; jmp element-loop
           (label element-loop-break)

           ;; Write our output number to output byte buffer as 1-byte barray
           "\x4C\x89\xEF" ; mov rdi, r13
           "\x48\xC7\xC6"(imm32 1)                                      ; mov rsi, 1
           "\x48\xB8" (aarrp/builtin-func-addr/byte-buffer-push-int64)  ; mov rax, bb_push_int64
           "\xFF\xD0"                                                   ; call rax

           "\x4C\x89\xEF" ; mov rdi, r13
           "\x4c\x89\xF6"                                               ; mov rsi, r14
           "\x48\xB8" (aarrp/builtin-func-addr/byte-buffer-push-int8)   ; mov rax, bb_push_byte
           "\xFF\xD0"                                                   ; call rax

           "\x48\xC7\xC0"(imm32 0) ; mov rax, 0

           "\x5B"      ; pop rbx
           "\x41\x5F"  ; pop r15
           "\x41\x5E"  ; pop r14
           "\x41\x5D"  ; pop r13
           "\x41\x5C"  ; pop r12
           "\xC3")))

      (RM
        (x86_64-linux
          (aarrp/barray-cat
           (REX B)"\x54"     ; push r12
           (REX B)"\x55"     ; push r13
           (REX B)"\x56"     ; push r14
           (REX B)"\x57"     ; push r15
           "\x53"            ; push rbx

           (REX W B)"\x89\xFC"   ; mov r12, rdi - input structure*
           (REX W B)"\x89\xF5"   ; mov r13, rsi - output byte buffer*

           ;; Write a placeholder output length
           (REX W R)"\x89\xEF"                                           ; mov rdi, r13
           (REX W)"\xC7\xC6"(imm32 0)                                    ; mov rsi, 0
           (REX W)"\xB8"(aarrp/builtin-func-addr/byte-buffer-push-int64) ; mov rax, bb_push_int64
           "\xFF\xD0"                                                    ; call rax

           ;; Error if not exactly 3 elements in input structure: RM reg mem
           (REX W B)"\x83\x3C\x24"(imm8 -4)              ; cmp qword[r12], -4
           "\x0F\x84"(label-rel-ref good-arg-count 4 LE) ; je good-arg-count

           (REX W)"\xBF"(MODRM-input-error addr 8 LE)        ; mov rdi, MODRM-input-error
           (REX W)"\xB8"(error-exit-fn barray-raw-addr 8 LE) ; mov rax, error-exit-fn
           "\xFF\xD0"                                        ; call rax

           (label good-arg-count)

           ;; Our second argument is a bit complicated to encode.
           ;;   * If it's a barray, we're addressing a register, not a memory location
           ;;     * This can be encoded exactly like the previous argument, just don't bitshift
           ;;   * If it's a parray, we're addressing a memory location
           ;;     * We currently use the format (m64|m32|m16|m8 base index scale displace)
           ;;       * base is always a register
           ;;       * index is either ascii 0 or a register
           ;;       * scale is always base-10 ascii
           ;;       * displace is always base-10 ascii
           ;;     * We need to know exactly what registers we have for these encoding rules, not
           ;;       just the register number. Thus, inside the memory operand we only accept
           ;;       register names.
           ;;     * If base == ascii_0 && index == ascii_0, use abs32/rip-rel with displace val
           ;;     * If base != ascii_0 && base != rbp_or_r13 && base != register_4 &&
           ;;       index == ascii_0 && displace == 0, we can encode this memory operand without a
           ;;       displacement or SIB byte with mod 00.
           ;;     * If base != ascii_0 && base != register_4 && index == ascii_0 &&
           ;;       displacement < 128 && displacement >= -128, we can encode this memory operand
           ;;       with mem+disp8 with mod 01
           ;;     * If base != register_4 && index == ascii_0 && displacement < 2^31 &&
           ;;       displacement >= -2^31, we can encode this memory operand with mem+disp8 with
           ;;       mod 10
           ;;     * If base != ascii_0 && index != register_4, we can encode this memory operand
           ;;       with an SIB byte (and displacement if present).

           ;; If our 2nd argument - element 3 - is a barray, output a register for our second arg,
           ;; and set mod to 11
           (REX W B)"\x8B\x7C\x24"(imm8 24)                 ; mov rdi, qword[r12+24]
           (REX W)"\x83\x3F"(imm8 0)                        ; cmp qword[rdi], 0
           "\x0F\x8C"(label-rel-ref is-memory-operand 4 LE) ; jl is-memory-operand

           (label-scope
             (REX B)"\xB6"(imm8 0) ; mov r14b, 0  - our output byte

             ;; If element 2 is a barray of 1 byte and < 8, or the byte in
             (REX W B)"\x8B\x7C\x24"(imm8 24)             ; mov rdi, qword[r12+24]
             (REX W)"\x83\x3F"(imm8 1)                    ; cmp qword[rdi], 1
             "\x0F\x85" (label-rel-ref not-raw-byte 4 LE) ; jne not-raw-byte
             "\x80\x7F"(imm8 8)(imm8 8)                   ; cmp byte[rdi+8], 8
             "\x0F\x8D"(label-rel-ref not-raw-byte 4 LE)  ; jge not-raw-byte
             "\x8A\x4F"(imm8 8)                           ; mov cl, byte[rdi+8]
             (REX B)"\x08\xCE"                            ; or r14b, cl
             "\xE9"(label-rel-ref good-reg2 4 LE)   ; jmp good-reg2
             (label not-raw-byte)

             ;; If element 2 is a barray of 1 byte, >= 48 & <= 55, parse the ascii base-10
             ;; number, then or the byte in
             (REX W B)"\x8B\x7C\x24"(imm8 24)                 ; mov rdi, qword[r12+24]
             (REX W)"\x83\x3F"(imm8 1)                        ; cmp qword[rdi], 1
             "\x0F\x85"(label-rel-ref not-ascii-10 4 LE)     ; jne not-ascii-10
             "\x80\x7F"(imm8 8)(imm8 48)                      ; cmp byte[rdi+8], 48
             "\x0F\x8C"(label-rel-ref not-ascii-10 4 LE)     ; jl not-ascii-10
             "\x80\x7F"(imm8 8)(imm8 55)                      ; cmp byte[rdi+8], 55
             "\x0F\x8F"(label-rel-ref not-ascii-10 4 LE)     ; jg not-ascii-10
             (REX W)"\xB8"(parse-int-fn barray-raw-addr 8 LE) ; mov rax, parse-int-fn
             "\xFF\xD0"                                       ; call rax - rdi already correct
             (REX B)"\x08\xC6"                                ; or r14b, al
             "\xE9"(label-rel-ref good-reg2 4 LE)       ; jmp good-reg2

             (label not-ascii-10)

             ;; If element 2 is a barray of length > 1, try to look up the register by name
             (REX W B)"\x8B\x7C\x24"(imm8 24)                    ; mov rdi, qword[r12+24]
             (REX W)"\x83\x3F"(imm8 2)                           ; cmp qword[rdi], 2
             "\x0F\x8C"(label-rel-ref not-reg-name 4 LE)         ; jl not-reg-name
             (REX W)"\xB8"(reg-name-to-num barray-raw-addr 8 LE) ; mov rax, reg-name-to-num
             "\xFF\xD0"                                          ; call rax
             (REX B)"\x08\xC6"                                   ; or r14b, al
             "\xE9"(label-rel-ref good-reg2 4 LE)                ; jmp good-reg2

             (label not-reg-name)

             ;; If we get here, error
             (REX W)"\xBF"(MODRM-input-error addr 8 LE)        ; mov rdi, MODRM-input-error
             (REX W)"\xB8"(error-exit-fn barray-raw-addr 8 LE) ; mov rax, error-exit-fn
             "\xFF\xD0"                                        ; call rax

             (label good-reg2)
             (REX W R)"\x89\xEF"                                          ; mov rdi, r13
             (REX W R)"\x89\xF6"                                          ; mov rsi, r14
             (REX W)"\xB8"(aarrp/builtin-func-addr/byte-buffer-push-int8) ; mov rax, bb_push_byte
             "\xFF\xD0"                                                   ; call rax
             "\xE9"(label-rel-ref mem-operand-done 4 LE))                 ; jmp mem-operand-done

           (label is-memory-operand)

           (label-scope
             (REX W B)"\x8B\x5C\x24"(imm8 24) ; mov rbx, qword[r12+24] - rbx = mem operand parray

             ;; Error if our memory operand is not 5 elements long
             (REX W)"\x83\x3B"(imm8 -6)                           ; cmp qword[rbx], -6
             "\x0F\x84" (label-rel-ref good-mem-operand-len 4 LE) ; je good-mem-operand-len

             (REX W)"\xBF"(MODRM-input-error addr 8 LE)        ; mov rdi, MODRM-input-error
             (REX W)"\xB8"(error-exit-fn barray-raw-addr 8 LE) ; mov rax, error-exit-fn
             "\xFF\xD0"                                        ; call rax

             (label good-mem-operand-len)

             ;; TODO error if our memory operand's first element is not m64|m32|m16|m8
             ;;      (maybe make a memory operand validator func)

             ;; Try rip-rel encoding
             (REX W)"\x89\xDF"                                            ; mov rdi, rbx
             (REX W R)"\x89\xEE"                                          ; mov rsi, r13
             (REX W)"\xB8"(RM-try-encode-rip-rel-fn barray-raw-addr 8 LE) ; mov rax, rip-rel-fn
             "\xFF\xD0"                                                   ; call rax
             (REX W)"\x83\xF8"(imm8 1)                                    ; cmp rax, 1
             "\x0F\x84"(label-rel-ref mem-operand-done 4 LE)              ; je mem-operand-done

             ;; Try mem encoding
             (REX W)"\x89\xDF"                                            ; mov rdi, rbx
             (REX W R)"\x89\xEE"                                          ; mov rsi, r13
             (REX W)"\xB8"(RM-try-encode-mem-fn barray-raw-addr 8 LE)     ; mov rax, mem-fn
             "\xFF\xD0"                                                   ; call rax
             (REX W)"\x83\xF8"(imm8 1)                                    ; cmp rax, 1
             "\x0F\x84"(label-rel-ref mem-operand-done 4 LE)              ; je mem-operand-done

             ;; Try mem+disp encoding
             (REX W)"\x89\xDF"                                             ; mov rdi, rbx
             (REX W R)"\x89\xEE"                                           ; mov rsi, r13
             (REX W)"\xB8"(RM-try-encode-mem+disp-fn barray-raw-addr 8 LE) ; mov rax, mem+disp-fn
             "\xFF\xD0"                                                    ; call rax
             (REX W)"\x83\xF8"(imm8 1)                                     ; cmp rax, 1
             "\x0F\x84"(label-rel-ref mem-operand-done 4 LE)               ; je mem-operand-done

             ;; TODO try mem+sib+disp encoding

             ;; Error if we got here, nobody succeeded in encoding this operand
             (REX W)"\xBF"(memop-error addr 8 LE)              ; mov rdi, memop-error
             (REX W)"\xB8"(error-exit-fn barray-raw-addr 8 LE) ; mov rax, error-exit-fn
             "\xFF\xD0")                                       ; call rax

           (label mem-operand-done)

           ;; Now that our r/m operand is encoded, let's 'or' in our first argument
           ;; (2nd element) to specify the register.

           ;; Our first argument - element 2 - can take any of the following forms:
           ;;   * A barray of length > 1: specifying a register by name
           ;;   * A barray of 1 byte: base-10 ascii number representing the register number
           ;;   * A barray of 1 byte: representing the register number (value always < 8)

           (label-scope
             (REX B)"\xB6"(imm8 0) ; mov r14b, 0  - our output byte

             ;;; If element 2 is a barray of 1 byte and < 8, bitshift+or the byte in
             (REX W B)"\x8B\x7C\x24"(imm8 16)             ; mov rdi, qword[r12+16]
             (REX W)"\x83\x3F"(imm8 1)                    ; cmp qword[rdi], 1
             "\x0F\x85" (label-rel-ref not-raw-byte 4 LE) ; jne not-raw-byte
             "\x80\x7F"(imm8 8)(imm8 8)                   ; cmp byte[rdi+8], 8
             "\x0F\x8D"(label-rel-ref not-raw-byte 4 LE)  ; jge not-raw-byte
             "\x8A\x4F"(imm8 8)                           ; mov cl, byte[rdi+8]
             "\xC0\xE1"(imm8 3)                           ; shl cl, 3
             (REX B)"\x08\xCE"                            ; or r14b, cl
             "\xE9"(label-rel-ref good-reg1 4 LE)   ; jmp good-reg1
             (label not-raw-byte)

             ;;; If element 2 is a barray of 1 byte, >= 48 & <= 55, parse the ascii base-10
             ;;; number, then bitshift+or the byte in
             (REX W B)"\x8B\x7C\x24"(imm8 16)                 ; mov rdi, qword[r12+16]
             (REX W)"\x83\x3F"(imm8 1)                        ; cmp qword[rdi], 1
             "\x0F\x85"(label-rel-ref not-ascii-10 4 LE)     ; jne not-ascii-10
             "\x80\x7F"(imm8 8)(imm8 48)                      ; cmp byte[rdi+8], 48
             "\x0F\x8C"(label-rel-ref not-ascii-10 4 LE)     ; jl not-ascii-10
             "\x80\x7F"(imm8 8)(imm8 55)                      ; cmp byte[rdi+8], 55
             "\x0F\x8F"(label-rel-ref not-ascii-10 4 LE)     ; jg not-ascii-10
             (REX W)"\xB8"(parse-int-fn barray-raw-addr 8 LE) ; mov rax, parse-int-fn
             "\xFF\xD0"                                       ; call rax - rdi already correct
             "\xC0\xE0"(imm8 3)                               ; shl al, 3
             (REX B)"\x08\xC6"                                ; or r14b, al
             "\xE9"(label-rel-ref good-reg1 4 LE)       ; jmp good-reg1

             (label not-ascii-10)

             ;;; If element 2 is a barray of length > 1, try to look up the register by name
             (REX W B)"\x8B\x7C\x24"(imm8 16)                 ; mov rdi, qword[r12+16]
             (REX W)"\x83\x3F"(imm8 2)                        ; cmp qword[rdi], 2
             "\x0F\x8C"(label-rel-ref not-reg-name 4 LE)      ; jl not-reg-name
             (REX W)"\xB8"(reg-name-to-num barray-raw-addr 8 LE) ; mov rax, reg-name-to-num
             "\xFF\xD0"                                       ; call rax
             "\xC0\xE0"(imm8 3)                               ; shl al, 3
             (REX B)"\x08\xC6"                                ; or r14b, al
             "\xE9"(label-rel-ref good-reg1 4 LE)       ; jmp good-reg1

             (label not-reg-name)

             ;;; If we get here, error
             (REX W)"\xBF"(MODRM-input-error addr 8 LE)        ; mov rdi, MODRM-input-error
             (REX W)"\xB8"(error-exit-fn barray-raw-addr 8 LE) ; mov rax, error-exit-fn
             "\xFF\xD0"                                        ; call rax

             (label good-reg1)

             ;; 'or' our reg1 into our result
             (REX W R)"\x89\xEF"                                           ; mov rdi, r13
             (REX W)"\xB8"(aarrp/builtin-func-addr/byte-buffer-get-buf)    ; mov rax, bb_get_buf
             "\xFF\xD0"                                                    ; call rax
             (REX R)"\x08\x70"(imm8 8))                                     ; or byte[rax+8], r14b

           ;; Update our placeholder length to current data length of byte buffer-8
           (REX W R)"\x89\xEF"                                                ; mov rdi, r13
           (REX W)"\xB8"(aarrp/builtin-func-addr/byte-buffer-get-data-length) ; mov rax, len
           "\xFF\xD0"                                                         ; call rax
           (REX W)"\x83\xE8"(imm8 8) ; sub rax, 8

           (REX W R)"\x89\xEF"                                                ; mov rdi, r13
           (REX W)"\xC7\xC6"(imm32 0)                                         ; mov rsi, 0
           (REX W)"\x89\xC2"                                                  ; mov rdx, rax
           (REX W)"\xB8"(aarrp/builtin-func-addr/byte-buffer-write-int64)     ; mov rax, write
           "\xFF\xD0"                                                         ; call rax

           (REX W)"\xC7\xC0"(imm32 0)                                         ; mov rax, 0

           "\x5B"         ; pop rbx
           (REX B)"\x5F"  ; pop r15
           (REX B)"\x5E"  ; pop r14
           (REX B)"\x5D"  ; pop r13
           (REX B)"\x5C"  ; pop r12
           "\xC3"))))     ; ret
    (
     (REX W)
     (RM rax (m64 r11 0 1 127))
     (aarrp/barray-cat (REX W) "\x89" (RM rdi (m64 rdi 0 1 2)))
     )))

; (m64 rdi 0 1 0)
