(aarrp/with-macros
; TODO build out these comments to describe generally how to encode x86_64 instructions from
; a table.

; REX: 0100WRXB
; * W: 1 = 64-bit operands, 0 = 32 bit operands
; * R: 1 = extend register access r8-r15
; * X: 1 = allow r8+ in SIB byte
; * B: 1 = R/M can use r8-r15

; MODRM: mod + reg + r/m
; * mod = addressing mode
;   * 00 memory, no displace
;   * 01 memory, 1 byte displace
;   * 10 memory, 4 byte displace
;   * 11 register direct
;
; * reg (3 bits):
;   * 000 rax/eax
;   * 001 rcx/ecx
;   * 010 rdx/edx
;   * 011 rbx/ebx
;   * 100 rsp/esp
;   * 101 rbp/ebp
;   * 110 rsi/esi
;   * 111 rdi/edi
;
; * reg (3 bits) when R is 1:
;   * 000 r8
;   * 001 r9
;   * 010 r10
;   * 011 r11
;   * 100 r12
;   * 101 r13
;   * 110 r14
;   * 111 r15
;
; * r/m (3 bits) when mod = 11 encodes another register. Refers to r8+ if REX.B = 1
;
; TODO doc how to encode memory operands
; TODO doc SIB byte

 ((imm64 ; Encodes imm64 literal from base-10 ASCII number
   (x86_64-linux
     (aarrp/barray-cat
      "\x41\x54"     ; push r12
      "\x41\x55"     ; push r13
      "\x41\x56"     ; push r14

      "\x49\x89\xFD" ; mov r13, rdi
      "\x49\x89\xF4" ; mov r12, rsi

      ;; If we got an invalid argument count (anything != 2), just expand to 0
      ;; TODO after we get error management functions in aarrp-land,
      ;;      error and exit instead
      "\x48\x83\x3F\xFD"                                 ; cmp qword[rdi], -3
      "\x0F\x84" (label-rel-ref correct-arg-count 4 LE)  ; je correct-arg-count

      "\x4C\x89\xE7"                                               ; mov rdi, r12
      "\x48\xC7\xC6\x08\x00\x00\x00"                               ; mov rsi, 8
      "\x48\xB8" (aarrp/builtin-func-addr/byte-buffer-push-int64)  ; mov rax, byte_buffer_push_int64
      "\xFF\xD0"                                                   ; call rax

      "\x4C\x89\xE7"                                               ; mov rdi, r12
      "\x48\xC7\xC6\x00\x00\x00\x00"                               ; mov rsi, 0
      "\x48\xB8" (aarrp/builtin-func-addr/byte-buffer-push-int64)  ; mov rax, byte_buffer_push_int64
      "\xFF\xD0"                                                   ; call rax

      "\x48\xB8\x00\x00\x00\x00\x00\x00\x00\x00" ; mov rax, 0
      "\xE9" (label-rel-ref epilogue 4 LE)       ; jmp epilogue

      (label correct-arg-count)

      ;; Parse 2nd item in parray as signed base 10 ASCII integer, write integer to output

      "\x4C\x89\xE7"                                               ; mov rdi, r12
      "\x48\xC7\xC6\x08\x00\x00\x00"                               ; mov rsi, 8
      "\x48\xB8" (aarrp/builtin-func-addr/byte-buffer-push-int64)  ; mov rax, byte_buffer_push_int64
      "\xFF\xD0"                                                   ; call rax

      "\x49\x8B\x7D\x10"                                           ; mov rdi, qword[r13+16]
      "\x48\xC7\xC6\x0A\x00\x00\x00"                               ; mov rsi, 10
      "\xE8" (label-rel-ref parse-int 4 LE)                        ; call parse-int

      "\x4C\x89\xE7"                                               ; mov rdi, r12
      "\x48\x89\xC6"                                               ; mov rsi, rax
      "\x48\xB8" (aarrp/builtin-func-addr/byte-buffer-push-int64)  ; mov rax, byte_buffer_push_int64
      "\xFF\xD0"                                                   ; call rax

      "\x48\xB8\x00\x00\x00\x00\x00\x00\x00\x00" ; mov rax, 0

      (label epilogue)
      "\x41\x5E" ; pop r14
      "\x41\x5D" ; pop r13
      "\x41\x5C" ; pop r12
      "\xC3"     ; ret

      ;;; parses a signed ascii integer from barray in rdi assuming it is in base rsi
      (label parse-int)
      (label-scope
       "\x41\x54"     ; push r12
       "\x41\x55"     ; push r13
       "\x41\x56"     ; push r14
       "\x41\x57"     ; push r15
       "\x53"         ; push rbx

       "\x49\x89\xFC" ; mov r12, rdi - r12 = input barray
       "\x49\x89\xF5" ; mov r13, rsi - r13 = base

       "\x4D\x8B\x3C\x24"     ; mov r15, qword[r12] - r15 = barray length
       "\x49\x83\xC4\x08"     ; add r12, 8 - move past length

       ;; Loop working right-to-left
       "\x4D\x31\xF6"                 ; xor r14, r14 - result
       "\x48\xC7\xC3\x01\x00\x00\x00" ; mov rbx, 1   - multiplier

       (label loop)
       (label-scope
         "\x49\x83\xFF\x00"                         ; cmp r15, 0
         "\x0F\x84" (label-rel-ref loop-break 4 LE) ; je loop-break

         ;; If r15 == 1 (the last char), and the char is '-', take the two's complement of
         ;; the result and break the loop.
         "\x49\x83\xFF\x01"                      ; cmp r15, 1
         "\x0F\x85" (label-rel-ref not-neg 4 LE) ; jne not-neg
         "\x43\x80\x7c\x3c\xff\x2d"              ; cmp byte[r12+r15-1], '-'
         "\x0F\x85" (label-rel-ref not-neg 4 LE) ; jne not-neg

         "\x49\xF7\xDE"                         ; neg r14
         "\xE9" (label-rel-ref loop-break 4 LE) ; jmp loop-break

         (label not-neg)

         ;; Parse digit
         "\x48\x31\xFF"         ; xor rdi, rdi
         "\x43\x8A\x7C\x3C\xFF" ; mov dil, byte[r12+r15-1]
         "\xE8" (label-rel-ref ascii-to-digit 4 LE) ; call ascii-to-digit

         ;; TODO error if digit >= base?
         ;; TODO error if digit < 0?

         "\x48\xF7\xE3" ; mul rbx - multiply digit by multiplier
         "\x49\x01\xC6" ; add r14, rax - add to result

         ;; Update multiplier
         "\x48\x89\xD8" ; mov rax, rbx
         "\x49\xF7\xE5" ; mul r13
         "\x48\x89\xC3" ; mov rbx, rax

         "\x49\xFF\xCF" ; dec r15
         "\xE9" (label-rel-ref loop 4 LE)) ; jmp loop
       (label loop-break)

       "\x4C\x89\xF0" ; mov rax, r14
       "\x5B"     ; pop rbx
       "\x41\x5F" ; pop r15
       "\x41\x5E" ; pop r14
       "\x41\x5D" ; pop r13
       "\x41\x5C" ; pop r12
       "\xC3") ; ret

      ;;; Converts a single ascii char to the digit it represents.
      ;;; Works up to base 36.
      (label ascii-to-digit)
      (label-scope
       "\x48\x89\xF8"                                      ; mov rax, rdi

       "\x48\x83\xF8\x39"                                  ; cmp rax, 57
       "\x0F\x8F" (label-rel-ref as-uppercase-letter 4 LE) ; jg as-uppercase-letter

       "\x48\x83\xE8\d048"                                 ; sub rax, 48
       "\xC3"                                              ; ret

       (label as-uppercase-letter)
       "\x48\x83\xF8\d090"                                 ; cmp rax, 90
       "\x0F\x8F" (label-rel-ref as-lowercase-letter 4 LE) ; jg as-lowercase-letter

       "\x48\x83\xE8\d055"                                 ; sub rax, 55
       "\xC3"                                              ; ret

      (label as-lowercase-letter)
       "\x48\x83\xE8\d087"                                 ; sub rax, 87
       "\xC3")))))                                         ; ret
 (imm64 5))
