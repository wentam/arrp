* make an implicit barray-cat for defining macro with with-macros
* now that builtin macros are called directly, not on the heap, we should be able to call directly everywhere instead of mov rax, foo; call foo
* make with_macros free all of it's macroexpansions, currently leaking
* implement x86_64 assembler (not as a builtin, and in machine code)
* implement aarrp/include (as a builtin probably)
  * probably use buffered_fd_reader
* implement elf64-relocatable (or maybe just elf-relocatable?)
* don't always malloc executable, make sure macro stack mallocs executable except when serving as data stack
* rework macro interface and all builtins to not use byte_buffer?
* are compare_barrays and barray_equalp the same function? We need to either remove one or document the difference.
* Put barray utility functions into a barray.asm, not util.asm
* make malloc not always executable (split into malloc and malloc_linux as per notes so that public malloc is never executable)
* make macro stack not always executable
* fix kv_stack_pop_by_key
* parray-cat
* implement macroexpand-1 in structural_macro_expand
* build macroexpand "walker" macro that allows you to tap spacebar to macroexpand-1 repeatedly.
   * problem: if I macroexpand-1 a 'with' macro, he greedy macroexpands his children so you can't really watch it go very well. I really want to try to come up with a way to do this nicely. Maybe simply allow you to put aarrp into a mode where structural_macro_expand always stops prints and waits for spacebar after each expansion. This could be exposed via a (with-macroexpand-walker my-stuff) macro that enters and exits this mode around my-stuff.
* with-namespace
  * (with-namespace x86_64-asm (mov rdi 5) (something-else)) will apply the prefix x86_64-asm to every macro it can where there is a macro defined for that prefix. Meaning it doesn't such something-else, but does touch mov
  * It would only effect locally-visible forms AKA implemented recursively BEFORE macroexpansion
  * builtin because it's needed to make the language practical
* with-namespace-alias
  * (with-namespace-alias (asm x86_64-asm) (asm/mov rdi, 5))
  * It would only effect locally-visible forms AKA implemented recursively BEFORE macroexpansion
  * builtin because it's needed to make the language practical
* namespace all the assembler macros
